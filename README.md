# Лабораторна робота №2 

**Тема: Робота з файлами та мережею**

**КОНТРОЛЬНІ ПИТАННЯ**

*1. У чому різниця між SetInterval та SetTimeOut?*  
setInterval та setTimeout є двома функціями в JavaScript, які використовуються для запуску коду через певний проміжок часу. setTimeout виконує функцію один раз через заданий проміжок часу, вказаний у мілісекундах. setInterval виконує функцію через заданий проміжок часу, але ця функція виконується знову та знову з періодичністю, яка вказана в мілісекундах.

*2. Що таке блокуючий код?*  
Блокуючий код (blocking code) - це тип коду, який блокує виконання програми до того часу, поки певна операція не буде завершена.
Коли виконується блокуючий код, весь процес програми зупиняється на час виконання цієї операції. Якщо в цей час програма очікує на завершення операції введення-виведення (I/O), то вона не може виконувати інші задачі, навіть якщо вони не пов'язані з I/O. Це може призвести до затримок в роботі програми, відчуття "зависання" та погіршення її продуктивності.
Приклади у JS:
1) Використання синхронних методів введення-виведення (I/O) таких як 	
fs.readFileSync:
> const fs = require('fs');  
> const fileContents = fs.readFileSync('/path/to/file');  
> console.log(fileContents);  

У цьому прикладі використовується метод fs.readFileSync, який блокує виконання програми до завершення операції зчитування з файлу. Програма не зможе продовжити свою роботу до того часу, поки ця операція не буде завершена.  
2) Використання setTimeout зі значенням таймера більшим за час запланованої функції  
3) Використання циклу, що триває довгий час

*3. Які переваги асинхронного читання з диску перед синхронним?*  
Асинхронне читання з диску має кілька переваг порівняно з синхронним читанням:
+ Ефективність: асинхронне читання з диску дозволяє програмі продовжувати виконання інших задач, тоді як диск забезпечує необхідні дані. Це дозволяє зменшити час очікування та підвищити продуктивність програми.
+ Масштабованість: з асинхронним читанням з диску, можна з легкістю читати дані з кількох джерел без блокування програми та зберігання додаткової пам'яті.
+ Відповідність асинхронності: у додатках, які працюють з мережевими джерелами даних, такі як веб-сайти, асинхронне програмування є надзвичайно важливим. Використання асинхронного читання з диску в таких додатках дозволяє забезпечити більш швидке та надійне завантаження сторінок та мінімізувати можливість блокування процесу через зависання.
+ Помилки: при асинхронному читанні з диску, можливість помилок менша, оскільки якщо диск не забезпечує необхідні дані, то програма може просто переключитися на виконання іншої задачі, замість того, щоб зависати та генерувати помилки.

*4. Яка різниця між Callbacks API, Promise API та async/await?*  
Callback API, Promise API та async/await - це різні способи управління асинхронним кодом в JavaScript.
+ Callback API - це найстаріший із них. Використовуючи callback-функції, можна виконувати асинхронний код в JavaScript. Функція, яка приймає callback, буде продовжувати виконання коду, поки асинхронна операція не завершиться, а потім викличе callback з результатом або помилкою. Callback API може бути складним для використання, коли виконується багато асинхронних операцій, оскільки код стає занадто вкладеним (так званий "callback hell").
+ Promise API - це спосіб управління асинхронним кодом, який був запроваджений в ES6. Promise - це об'єкт, який представляє асинхронну операцію, і може перебувати у станах "pending" (очікується результат), "fulfilled" (успішно виконано з результатом) або "rejected" (помилка). Promise може бути оброблений з використанням методів then() та catch(), які дозволяють обробити результат або помилку від асинхронної операції. Promise API є більш читабельним та простим у використанні, ніж Callback API.
+ async/await - це синтаксис, який був доданий в ES2017. async/await є способом використання Promise API у зручному синтаксисі. За допомогою async/await можна створювати асинхронний код, який виглядає як звичайний синхронний код. Ключове слово async вказує на те, що функція є асинхронною, а ключове слово await зупиняє виконання коду до того моменту, коли Promise буде виконано. async/await може бути зручним способом управління асинхронним кодом, оскільки він дозволяє уникнути занадто вкладеного коду, який може бути складним для читання та зрозуміння.

*5. Як обробляються помилки при використанні Promise API?*  
При використанні Promise API помилки обробляються за допомогою методу catch(). Якщо Promise переходить до стану "rejected", він викликає метод catch(), в якому можна обробити помилку.

*6. Як створити директорію через модуль fs?*  
+ fs.mkdir() - є асинхронним методом, який створює нову директорію за вказаною шляхом. Цей метод приймає 3 аргументи: шлях до директорії, режим створення та зворотний виклик (callback) функцію. Режим створення може бути налаштований за допомогою параметру mode. Якщо директорію не вдалося створити, то викликається функція зворотного виклику з об'єктом помилки.
+ fs.mkdirSync() - є синхронним методом, який створює нову директорію за вказаною шляхом. Цей метод працює так само, як і fs.mkdir(), але замість зворотного виклику функції він повертає помилку або undefined в разі успіху.
+ fsPromises.mkdir() - є асинхронним методом, який створює нову директорію за вказаною шляхом та повертає об'єкт Promise. Цей метод є альтернативою fs.mkdir() та дозволяє використовувати асинхронний код з промісами. При успішному створенні директорії об'єкт Promise повертається зі значенням undefined, а при виникненні помилки - Promise буде відхилений з об'єктом помилки.
Параметр mode в методі fs.mkdir() відповідає за режим (mode) створення директорії. Цей параметр використовується для задання прав доступу (permissions) до створеної директорії.
